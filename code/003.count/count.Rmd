---
title: "Count"
author: "Sneha Sundar"
date: "`r Sys.Date()`"
output: html_document
---

Count tra genes, functional tra genes and classify genomes according to Coluzzi et al. classification scheme. These will be the tables used for all subsequent analyses. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Libraries

```{r}
library(here)
library(tidyverse)

source(here("code/000.tools/helpers.R"))
source(here("code/000.tools/plot.R"))
```


## Read in  blast results and metadata for the genomes

Preprocessed blast hits:
have the tra gene metadata (details of the query they were closest to)
only the best gene hit on the contig picked
removed vagd, orf1 and proq/fino, 
have a pid of at least 50 and a qcov of at least 30. 
lone traT and trbH hits are removed since these seem to be overrepresented on chromosomal backgrounds


```{r}
blast_fp <- here("data/processed/002.find_genes/pires1200_onlyblastcontigs_rmnonF-like_trantotraf/pires1200blast_pid_50_qcov30_rm1hitsTRUE_rmnonF-like.tsv")

pires1200_blast <- read.table(blast_fp,header = T,sep = '\t', quote = "")


pires1200_metadata <- read.table(here("data/raw/pires_1200/pires_1200_ecoli_metadata.tsv"),header = T,sep = '\t', quote = "")

```


## Read in bakta results

Contains only the contigs that have also been found out by blast .


```{r}
INPUT_BAKTA_FILE <- here("data/processed/002.find_genes/pires1200_onlyblastcontigs_rmnonF-like_trantotraf/pires1200bakta_onlyblastcontigs_rmnonF-like_trantotraf.tsv")

pires1200_bakta <- load_processed_bakta(INPUT_BAKTA_FILE) 


```



## Read in blast summary tables at the contig and genome level

```{r}
genome_summary_df <- summarise_at_genome_level(pires1200_blast)


contig_summary_df <- summarise_at_contig_level(pires1200_blast)


genome_summary_df

summarise
```


# Count detected genes

## 1. By Blast

```{r}
GENOMES <- genome_summary_df$target_genome
```


```{r}
mat_count_genome <- t(sapply(GENOMES,count_tra_genes_in_genome, pires1200_blast  ,TRA_GENES_GROUP$TRA_GENES,simplify = T))


mat_PreAbs_genome <- mat_count_genome > 0
```



```{r}
#avg gene copy number per genome
genome_summary_df <- genome_summary_df %>% mutate(mean_n_hits.blast = n_hits_genome/36)
```

Splitting the distribution into intervals

Several problems with this
The cuts seem fairly arbitrary to me. 
and I can just show this with a complete histogram

```{r}
#split an integer vector along its entire range according to specified breaks
breaks_vec <- c(min(genome_summary_df$n_hits_genome),5,30,40,max(genome_summary_df$n_hits_genome))

intervals <- cut(genome_summary_df$n_hits_genome,breaks = breaks_vec,include.lowest = T,right = F)

genome_summary_df <- genome_summary_df %>% mutate(n_hits_genome_category = intervals)

```


## 2. By bakta

But remember bakta results are influenced by blast results in the sense that only those contigs where a hit was found by blast were considered. 

But bakta is more stringent on gene calling. Higher qcov thresholds. 


```{r}

mat_count_genome_bakta <- t(sapply(GENOMES,count_tra_genes_in_genome_bakta, pires1200_bakta,TRA_GENES_GROUP$TRA_GENES,simplify = T))


mat_PreAbs_genome_bakta <- (mat_count_genome_bakta > 0)*1

```

```{r}
genome_summary_df <- genome_summary_df %>% mutate(bakta.n_hits_genome = rowSums(mat_count_genome_bakta))


genome_summary_df <- genome_summary_df %>% mutate(has_tra_hit = (bakta.n_hits_genome > 0)*1)


genome_summary_df[,"n.multihit.genes"] <- rowSums(mat_count_genome_bakta > 1)


genome_summary_df[,"bakta.n_distinct_hits"] <- rowSums(mat_PreAbs_genome_bakta)
```




```{r}
breaks_vec <- c(min(genome_summary_df$bakta.n_hits_genome),5,23,36,max(genome_summary_df$bakta.n_hits_genome))

intervals <- cut(genome_summary_df$bakta.n_hits_genome, breaks = breaks_vec ,include.lowest = T,right = F)

genome_summary_df <- genome_summary_df %>% mutate(bakta.n_hits_genome_category = factor(intervals, levels = levels(intervals)))

genome_summary_df
```


# Count functional transfer operons

## from koraiman 2018

Genes that are "essential" for transfer. Mutations in these genes have been shown to block or reduce transfer and have a demonstrated function. Entry and surface exclusion genes have not been included in this list. 
Koraiman et al 2018, Frost et al. 1994

```{r}
ESS_TRA <- TRA_GENES_GROUP %>% filter(Function != "nonessential", Function != "self-transfer prevention", TRA_GENES != "fino" ) %>% pull(TRA_GENES)

ESS_TRA
```



```{r}
is_functional_vec <- apply(mat_count_genome_bakta, MARGIN = 1,FUN = is_functional,ESS_TRA,length(ESS_TRA) )


genome_summary_df <- genome_summary_df %>% mutate(is.functional = is_functional_vec)

genome_summary_df[,"n.distinct.func.genes"] <- rowSums(mat_count_genome_bakta[,ESS_TRA]>0)
genome_summary_df[,"n.func.genes"] <-  rowSums(mat_count_genome_bakta[,ESS_TRA])

```

```{r}

ESS_TRA_NOREG <- TRA_GENES_GROUP %>% filter(Function != "nonessential", Function != "self-transfer prevention", !TRA_GENES %in% c("tram","traj","tray","fino")  ) %>% pull(TRA_GENES)


is_functional_vec <- apply(mat_count_genome_bakta, MARGIN = 1,FUN = is_functional,ESS_TRA_NOREG,length(ESS_TRA_NOREG) )


genome_summary_df <- genome_summary_df %>% mutate(is.functional.noreg = is_functional_vec)

genome_summary_df[,"n.distinct.func.genes.noreg"] <- rowSums(mat_count_genome_bakta[,ESS_TRA_NOREG]>0)
genome_summary_df[,"n.func.genes.noreg"] <-  rowSums(mat_count_genome_bakta[,ESS_TRA_NOREG])

```


## from Coluzzi et al. 2022

What if we use a functional classification to describe the distribution of hits rather than solely based on total number of hits detected?

Using the system of conjugative plasmid classification in Coluzzi et al. 2022:

"A plasmid was considered conjugative (pCONJ) when it
encoded one or several relaxases, a VirB4 (which is traC in F-like plasmid), a T4CP (traD in F-like plasmids), and a
minimum number of additional MPF proteins (defined as 3 for Type F). The latter
threshold varies according to the MPF type: two proteins
for MPF FA and MPF FATA and three for the other MPF types
(B, C, F, G, I, and T). These are values lower than previously
used in Cury et al. (2018) to make the assessment of a tran-
sition from pCONJ to pMOB conservative. A plasmid was
considered mobilizable (pMOB) when it encoded a relax-
ase but lacked the conditions to be conjugative (misses
T4CP, VirB4, or a sufficient number of the other compo-
nents). Plasmids encoding a relaxase and ,5 MPF proteins
were classed pMOBs (supplementary fig. S1,
Supplementary Material online). To pinpoint cases where
plasmids encode several genes typical of conjugative ele-
ments, but not enough to allow classing them as pCONJ,
we classed mobilizable plasmids containing more than
five proteins involved in the conjugative transfer (apart
from the first relaxase, either MPF proteins, T4CP, or add-
itional relaxases) as pdCONJ."


pdconj are a subcategory of mobilizable plasmids. 


```{r}

MPF_GENES <- c("trab","trae","traf","trag","trah","trak","tral","tran","trau","trav","traw","trbc")

reorder_idx <- match(TRA_GENES_GROUP$TRA_GENES,MPF_GENES)

MPF_GENES <- MPF_GENES[reorder_idx[!is.na(reorder_idx)]]

mandatory <-c("trac","trad","trai") #atpase, t4cp, trai

```


```{r}
genome_summary_df[, "n.distinct.MPF_GENES"] <- rowSums(mat_PreAbs_genome_bakta[,MPF_GENES])

yes_no_mandatory <- apply(mat_count_genome_bakta, MARGIN = 1,FUN = is_functional,mandatory,length(mandatory))

genome_summary_df[, "has_mandatory"] <- yes_no_mandatory


genome_summary_df[,"has_relaxase"] <- (mat_PreAbs_genome_bakta[,"trai"])


```



Do the genomes have all the mandatory genes? And at least 3 of the MPF genes . This is the same threshold used in Coluzzi et al. 2022. 

```{r}
thres_mpf <- 3

yes_no_mpf <- apply(mat_count_genome_bakta, MARGIN = 1,FUN = is_functional,MPF_GENES,thres_mpf)

is.func.coluzzi <- (yes_no_mandatory & yes_no_mpf)

genome_summary_df[,paste0("is.functional.coluzzi.",thres_mpf)] <- is.func.coluzzi

```

```{r}
thres_mpf <- 6

yes_no_mpf <- apply(mat_count_genome_bakta, MARGIN = 1,FUN = is_functional,MPF_GENES,thres_mpf)

is.func.coluzzi <- (yes_no_mandatory & yes_no_mpf)

genome_summary_df[,paste0("is.functional.coluzzi.",thres_mpf)] <- is.func.coluzzi
```

```{r}
thres_mpf <- 12

yes_no_mpf <- apply(mat_count_genome_bakta, MARGIN = 1,FUN = is_functional,MPF_GENES,thres_mpf)

is.func.coluzzi <- (yes_no_mandatory & yes_no_mpf)

genome_summary_df[,paste0("is.functional.coluzzi.",thres_mpf)] <- is.func.coluzzi
```


```{r}
genome_summary_df <- genome_summary_df %>%
  mutate(mob_classification_coluzzi = case_when(
     is.functional.coluzzi.3 == T ~ "conj",
    has_relaxase == T & (has_mandatory == F | is.functional.coluzzi.3 == F) & n.distinct.func.genes <= 6 ~ "mob",
    ((has_relaxase == T & (has_mandatory == F | is.functional.coluzzi.3 == F)) & n.distinct.func.genes > 6) ~ "pdconj",
    has_relaxase == F & n.distinct.func.genes > 0 ~ "mobless",
    n.distinct.func.genes == 0 ~ "no.transfer.gene"
  ))
```



```{r}
genome_summary_df <- genome_summary_df %>%
  mutate(mob_classification = case_when(
     is.functional.coluzzi.12 == T ~ "conj",
    has_relaxase == T & (has_mandatory == F | is.functional.coluzzi.12 == F) ~ "mob",
    has_relaxase == F & is.functional.coluzzi.12 == F & n.distinct.func.genes > 0 ~ "mobless",
    n.distinct.func.genes == 0 ~ "no.transfer.gene"
  ))


genome_summary_df$mob_classification %>% table()

```



# Save final count table

```{r}
#better that it is the same folder that the blast and bakta tables used to generate the summary is
out_folder <- here("data/processed/002.find_genes/pires1200_onlyblastcontigs_rmnonF-like_trantotraf")


write.table(genome_summary_df, paste0(out_folder, "/","genome_tra_count_summary.tsv"),sep = '\t',quote = F,row.names = F)


```



# Save computed count matrices



```{r}
write.table(mat_count_genome, paste0(out_folder, "/","blast_count_matrix.tsv"),sep = "\t",quote = F,row.names = T)

write.table(mat_count_genome_bakta, paste0(out_folder, "/","bakta_count_matrix.tsv"),sep = "\t",quote = F,row.names = T)

```


